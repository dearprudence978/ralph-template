---
name: spec-to-prd
description: Transform feature ideas into industry-standard specifications and split them into bite-sized PRDs with JSON-based tracking for Ralph loop execution. Includes automatic codebase analysis to discover project patterns. Use when the user wants to create a spec, generate PRDs, plan a feature, or prepare tasks for autonomous implementation. Triggers on "create spec", "generate PRD", "plan feature", "ralph prep", or when working in the ralph-specs/ directory.
---

# Spec-to-PRD Skill

Transform feature ideas into structured specifications and actionable PRD tasks with JSON-based tracking for Ralph loop execution.

## Workflow Overview

This skill follows a four-phase process:

1. **Discovery Phase**: Gather requirements through targeted questions
2. **Codebase Analysis**: Scan the repo to discover patterns and conventions
3. **Spec Generation**: Create comprehensive technical specification  
4. **PRD Decomposition**: Split spec into user stories tracked via `prd-phase-{N}-{name}.json`

---

## Phase 1: Discovery

When the user provides a feature idea, gather essential information through targeted questions.

### Required Information
- Feature name and high-level description
- Target users/personas
- Core functionality (must-haves)
- Nice-to-haves (optional features)
- Technical constraints or preferences
- Success metrics

### Discovery Approach
Ask a maximum of 3-5 questions per round. Focus on:
1. "What problem does this feature solve for users?"
2. "What's the minimum functionality needed for this to be useful?"
3. "Are there any technical constraints I should know about?"

Continue until sufficient detail exists to write a comprehensive spec.

---

## Phase 2: Codebase Analysis

Before generating specs, analyze the existing codebase to discover patterns. This ensures Ralph follows project conventions from the start.

### Step 2.1: Scan Project Structure

```bash
# List top-level structure
ls -la

# Check for common source directories
ls -la src/ 2>/dev/null || ls -la app/ 2>/dev/null || ls -la lib/ 2>/dev/null

# Check for config files
ls -la *.json *.config.* .* 2>/dev/null | head -20
```

### Step 2.2: Read Key Configuration Files

**Package/Project Config:**
- `package.json` - Dependencies, scripts, project type
- `tsconfig.json` - TypeScript configuration
- `pyproject.toml` / `requirements.txt` - Python projects
- `Cargo.toml` - Rust projects
- `go.mod` - Go projects

**Linting/Formatting:**
- `.eslintrc*` - ESLint rules
- `.prettierrc*` - Prettier settings
- `biome.json` - Biome config

**Database/ORM:**
- `prisma/schema.prisma` - Prisma schema
- `drizzle.config.ts` - Drizzle config

**Testing:**
- `jest.config.*` - Jest configuration
- `vitest.config.*` - Vitest configuration

### Step 2.3: Sample Existing Code

Read 2-3 existing source files to detect:
- Naming conventions (camelCase, snake_case, PascalCase)
- Export style (named vs default exports)
- Function style (arrow functions vs function declarations)
- Async patterns (async/await vs .then())
- Error handling patterns
- Import organization

### Step 2.4: Generate progress.txt

Create `ralph-specs/progress.txt` with all discovered patterns:

```markdown
# Progress Log - [PROJECT_NAME]
# Auto-generated by codebase analysis on [DATE]
# Ralph reads this at the start of each iteration

## Codebase Patterns

### Project Type
- Language: [TypeScript/JavaScript/Python/Go/Rust/etc.]
- Framework: [Next.js/Express/FastAPI/Gin/etc.]
- Package Manager: [npm/yarn/pnpm/pip/cargo/etc.]
- Node Version: [from .nvmrc or engines field]

### Code Style (detected from existing files)
- Naming: [camelCase for variables, PascalCase for types, etc.]
- Exports: [Named exports / Default exports]
- Functions: [Arrow functions / Function declarations]
- Async: [async/await / Promises / callbacks]
- Semicolons: [Yes / No]
- Quotes: [Single / Double]
- Indentation: [2 spaces / 4 spaces / tabs]

### File Organization (detected from directory structure)
- Source root: [src/ / app/ / lib/]
- Services: [src/services/*.service.ts]
- Types/Interfaces: [src/types/*.ts]
- Utilities: [src/utils/]
- Routes/Controllers: [src/routes/ / src/controllers/]
- Middleware: [src/middleware/]
- Tests: [Co-located *.test.ts / __tests__/ folder / tests/]

### Database
- ORM: [Prisma / Drizzle / TypeORM / SQLAlchemy / None]
- Database: [PostgreSQL / MySQL / SQLite / MongoDB]
- Schema location: [prisma/schema.prisma / etc.]
- Migration command: [npm run db:migrate / etc.]
- Generate command: [npm run db:generate / etc.]

### Testing
- Framework: [Jest / Vitest / Mocha / pytest / go test]
- Run all tests: [npm run test]
- Run specific: [npm run test -- --grep 'pattern']
- Coverage: [npm run test:coverage]

### Available Scripts (from package.json or Makefile)
- Build: [npm run build]
- Dev: [npm run dev]
- Lint: [npm run lint]
- Type check: [npm run typecheck]
- Format: [npm run format]

### Key Dependencies Already Installed
[List relevant dependencies that might be useful for this feature]
- [dependency]: [version] - [what it's for]

### Existing Utilities to Reuse
[List existing utilities, helpers, or patterns to reuse]
- [path/to/file.ts] - [description of what it does]

### Known Patterns from Existing Code
[Patterns observed in the codebase]
- [e.g., "All API responses use { success, data, error } shape"]
- [e.g., "Errors extend BaseError class in src/errors/"]
- [e.g., "Route handlers use asyncHandler wrapper"]

### Environment Variables (from .env.example or config)
[List relevant environment variables]
- [VAR_NAME] - [description]

---

## Completed Stories
[Ralph appends here as stories complete]

---

## Learnings
[Ralph adds discoveries here to avoid repeating mistakes]

---

## Blockers Encountered
[Ralph documents blocking issues here]
```

### For Greenfield Projects

If minimal existing code is detected, generate a **recommended patterns** template based on:
- The tech stack mentioned in discovery
- Common conventions for that stack
- User preferences if stated

Mark assumed patterns clearly:
```markdown
### Code Style (Recommended - minimal existing code detected)
- Naming: camelCase for variables, PascalCase for types
- Exports: Named exports (better tree-shaking)
```

---

## Phase 3: Spec Generation

Generate the spec using the template in `references/spec-template.md`.

**Output location**: `ralph-specs/specs/[SPEC_ID]-[feature-name].md`

### SPEC_ID Format
Use a short, unique identifier: `AUTH`, `NOTIF`, `DASH`, `PAY`, `API`, etc.

### Spec Quality Checklist
- [ ] Executive summary is clear and concise
- [ ] Problem statement is specific and measurable
- [ ] User stories have testable acceptance criteria
- [ ] Technical design is actionable
- [ ] Success metrics are quantifiable

---

## Phase 4: PRD Decomposition with JSON Tracking

Split the spec into user stories tracked in a phase PRD file.

### File Naming Convention

PRD files MUST follow this naming pattern to work with `/run-phase` and `/close-phase`:

```
ralph-specs/prd-phase-{N}-{feature-slug}.json
```

Where:
- `{N}` is the phase number (1, 2, 3...). Ask the user or check existing `prd-phase-*.json` files to determine the next number.
- `{feature-slug}` is a kebab-case name for the feature (e.g., `authentication`, `infrastructure`, `billing`)

**Examples:**
- `ralph-specs/prd-phase-1-infrastructure.json`
- `ralph-specs/prd-phase-2-authentication.json`
- `ralph-specs/prd-phase-3-billing.json`

The branch name is derived from the filename: `prd-phase-1-infrastructure.json` â†’ `feature/phase-1-infrastructure`

### Generate Phase PRD File

Create `ralph-specs/prd-phase-{N}-{feature-slug}.json`:

```json
{
  "project": "[Feature Name]",
  "specId": "[SPEC_ID]",
  "branchName": "feature/phase-{N}-{feature-slug}",
  "description": "[Brief description of the feature]",
  "specFile": "specs/[SPEC_ID]-[feature-slug].md",
  "userStories": [
    {
      "id": "[SPEC_ID]-001",
      "title": "[Task title]",
      "description": "[What to implement - 1-2 sentences]",
      "category": "[setup|core|api|ui|test|docs]",
      "acceptanceCriteria": [
        "[Specific, testable criterion 1]",
        "[Specific, testable criterion 2]",
        "[Specific, testable criterion 3]"
      ],
      "verificationCommands": [
        "npm run typecheck",
        "npm run test -- --grep '[pattern]'"
      ],
      "filesToModify": [
        "src/path/to/file.ts"
      ],
      "dependsOn": [],
      "priority": 1,
      "complexity": "simple",
      "passes": false,
      "notes": ""
    }
  ],
  "globalSuccessCriteria": [
    "All tests pass",
    "No linter errors",
    "TypeScript compiles without errors",
    "Build succeeds"
  ],
  "createdAt": "[ISO timestamp]",
  "updatedAt": "[ISO timestamp]"
}
```

### User Story Guidelines

**Sizing**: Each story should be completable in 1-3 Ralph iterations (1-5 files max).

**Acceptance Criteria**: Must be specific and testable.
- Bad: "Works correctly"
- Good: "Returns 200 status with user object containing id, email, createdAt fields"

**Verification Commands**: Include actual commands Ralph can run.

**Dependencies**: Use `dependsOn` array with story IDs. Ralph skips stories with unmet dependencies.

**Priority**: Lower numbers = higher priority. Stories execute in priority order.

### Task Categories

| Category | Description | Typical Priority |
|----------|-------------|------------------|
| `setup` | Database schemas, config, base classes | 1-2 |
| `core` | Business logic, services | 3-5 |
| `api` | Endpoints, controllers | 4-6 |
| `ui` | Components, pages | 5-7 |
| `test` | Test coverage | 8-9 |
| `docs` | Documentation | 10 |

---

## Output Format

After completing all phases, report:

```
ðŸ“‹ Spec-to-PRD Complete

Codebase Analysis:
- Language: [detected]
- Framework: [detected]  
- Test Framework: [detected]
- ORM: [detected or none]
- Patterns discovered: [N]

Generated Files:
- Spec: ralph-specs/specs/[SPEC_ID]-[name].md
- PRD: ralph-specs/prd-phase-{N}-{feature-slug}.json
- Progress: ralph-specs/progress.txt

User Stories: [N] total
1. [SPEC_ID]-001: [Title] - [category] - [complexity]
2. [SPEC_ID]-002: [Title] - [category] - [complexity]
...

Dependencies:
- [SPEC_ID]-002 depends on [SPEC_ID]-001
- [SPEC_ID]-003 depends on [SPEC_ID]-001, [SPEC_ID]-002

Ready to Run Ralph:

/run-phase prd-phase-{N}-{feature-slug}.json

Check Progress:
cat ralph-specs/prd-phase-{N}-{feature-slug}.json | jq '.userStories[] | {id, title, passes}'
```

---

## References

- **Spec Template**: See `references/spec-template.md`
- **PRD JSON Schema**: See `references/prd-schema.md`
- **PRD Template**: See `references/prd-template.md`
- **Progress Template**: See `references/progress-template.md`

---

## Best Practices

1. **JSON as Source of Truth**: `prd-phase-{N}-{name}.json` is the master tracking file per phase
2. **Atomic Stories**: Each story should be independently completable
3. **Testable Criteria**: Every criterion must be verifiable via commands
4. **Dependency Clarity**: Use `dependsOn` to prevent premature story execution
5. **Progress File**: Auto-populated but review and supplement if needed
6. **Verification First**: Include actual runnable commands
7. **Scope Control**: If >10 stories, consider splitting into multiple specs
8. **Review Before Running**: Always review generated files before starting Ralph
